\documentclass[12pt]{article}
\renewcommand*\rmdefault{ppl}
\usepackage[margin=2cm]{geometry} \geometry{letterpaper}
\usepackage[parfill]{parskip}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[style=numeric,backref=true,backrefstyle=none,abbreviate=false,urldate=iso,seconds=true]{biblatex} \addbibresource{totsum.bib}
\usepackage{csquotes}
\usepackage{amssymb,amsmath,amsthm}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikzscale}
\usepackage{pgfplots} \pgfplotsset{compat=1.15}
\usepackage{url}
\usepackage{multicol}
\usepackage[yyyymmdd,hhmmss]{datetime}
\usepackage[bottom]{footmisc}
\usepackage{hyperref}
\usepackage{color} \newcommand{\todo}[0]{{\textcolor{red}{\textbf{TODO: }}}}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[linesnumbered,vlined,boxed,ruled,algonl]{algorithm2e}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\newcommand{\eqn}[1]{\begin{displaymath} #1 \end{displaymath}}
\newcommand{\neqn}[1]{\begin{equation} #1 \end{equation}}
\newcommand{\tweqn}[1]{\begin{displaymath}\resizebox{\textwidth}{!}{$\displaystyle #1 $}\end{displaymath}}
\newcommand{\ntweqn}[1]{\begin{equation}\resizebox{\textwidth}{!}{$\displaystyle #1 $}\end{equation}}
\newcommand{\floor}[1]{{\left\lfloor #1 \right\rfloor}}
\newcommand{\ceil}[1]{{\left\lceil #1 \right\rceil}}
\newcommand{\vect}[1]{\left\langle #1 \right\rangle}
\newcommand{\deriv}[2]{\frac{d #1}{d #2}}
\newcommand{\derop}[1]{\frac{d}{d #1}}
\newcommand{\partiald}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\partialop}[1]{\frac{\partial}{\partial #1}}
\newcommand{\integral}[4]{\displaystyle\int_{#3}^{#4} \! #1 \, d#2}
\newcommand{\dintegral}[4]{\displaystyle\int\!\!\!\!\int_{#3}^{#4} #1 \, d#2}
\newcommand{\tintegral}[4]{\displaystyle\int\!\!\!\!\int\!\!\!\!\int_{#3}^{#4} #1 \, d#2}
\newcommand{\disp}[0]{\displaystyle}
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\grad}[0]{\vec{\nabla\!}\,}
\newcommand{\epsil}[0]{\varepsilon}
\newcommand{\eval}[3]{\left. #1 \right|_{#2}^{#3}}
\newcommand{\realpart}[1]{{\mathfrak{Re}\!\left\{#1\right\}}}
\newcommand{\ipart}[1]{{\mathfrak{Im}\!\left\{#1\right\}}}
\newcommand{\set}[1]{{\left\{#1\right\}}}
\newcommand{\lcm}[0]{\operatorname{lcm}}
\newcommand{\defeq}[0]{\overset{\mathrm{def}}{=}}
\newcommand{\oeis}[0]{$^{\texttt{OE}}_{\texttt{IS}}$}
\newcommand{\oeisref}[1]{$^{\texttt{OE}}_{\texttt{IS}}$~\href{https://oeis.org/#1}{#1}}
\newcommand{\quadtext}[1]{\quad \text{#1} \quad}
\newcommand{\qquadtext}[1]{\qquad \text{#1} \qquad}

\allowdisplaybreaks[4]

\def\grabtimezone #1#2#3#4#5#6#7#8#9{\grabtimezoneB}
\def\grabtimezoneB #1#2#3#4#5#6#7{\grabtimezoneC}
\def\grabtimezoneC #1#2'#3'{$#1$#2:#3}
\newcommand{\timezone}[0]{UTC\expandafter \grabtimezone\pdfcreationdate}
\newcommand{\currentdate}{\the\year--\twodigit{\the\month}--\twodigit{\the\day}}
\newcommand{\currentdatetime}{\currentdate\ / \currenttime}%\ \timezone}

\title{Computation of the Totient Summatory Function}
\author{Lucas A. Brown}
\date{\currentdatetime}

\usepackage{fancyhdr}
\usepackage{lastpage}
\pagestyle{fancy}
\fancyhf{}
\lhead{} \chead{Computation of the Totient Summatory Function} \rhead{}
\lfoot{\currentdatetime} \cfoot{} \rfoot{Page \thepage\ of \pageref{LastPage}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\setlength{\headheight}{15pt}

\begingroup
    \makeatletter
    \@for\theoremstyle:=definition,remark,plain\do{%
        \expandafter\g@addto@macro\csname th@\theoremstyle\endcsname{%
            \addtolength\thm@preskip\parskip
            }%
        }
\endgroup
\makeatletter
\renewenvironment{proof}[1][\proofname]{\par
  \vspace{-\topsep}% remove the space after the theorem
  \pushQED{\qed}%
  \normalfont
  \topsep0pt \partopsep0pt % no space before
  \trivlist
  \item[\hskip\labelsep
        \itshape
    #1\@addpunct{.}]\ignorespaces
}{%
  \popQED\endtrivlist\@endpefalse
  \addvspace{0pt} % some space after
}
\makeatother
\makeatletter
\newenvironment{solution}[1][\proofname]{\par
  \vspace{-\topsep}% remove the space after the theorem
  \pushQED{\qed}%
  \normalfont
  \topsep0pt \partopsep0pt % no space before
  \trivlist
  \item[\hskip\labelsep
        \bfseries
    Solution #1\@addpunct{.}]\ignorespaces
}{%
  \popQED\endtrivlist\@endpefalse
  \addvspace{0pt} % some space after
}
\makeatother
\usepackage{thmtools}
\declaretheorem[style=plain]{theorem}
\declaretheorem[sibling=theorem,style=plain]{corollary}
\declaretheorem[sibling=theorem,style=plain]{lemma}
\declaretheorem[sibling=theorem,style=plain]{proposition}
\declaretheorem[sibling=theorem,style=plain]{conjecture}
\declaretheorem[sibling=theorem,style=definition,qed=$\clubsuit$]{definition}
\declaretheorem[sibling=theorem,style=definition,qed=$\clubsuit$]{observation}
\declaretheorem[sibling=theorem,style=definition,qed=$\clubsuit$]{fact}
\declaretheorem[sibling=theorem,style=definition,qed=$\spadesuit$]{example}
\declaretheorem[sibling=theorem,style=definition]{notation}
\declaretheorem[sibling=theorem,style=definition]{question}
\declaretheorem[sibling=theorem,style=remark]{remark}
\declaretheorem[style=definition]{problem}

\renewcommand\qedsymbol{$\blacksquare$}

\hypersetup{
    pdftitle={On the Summation of the Totient Function},
    pdfauthor={Lucas A. Brown},
    pdfsubject={},
    pdfkeywords={},
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue,
    %hidelinks,
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\showcode}[1]{Filename: \texttt{#1.py} \lstinputlisting[language=Python]{code/#1.py}}

\newcommand{\floordiv}[2]{\floor{\frac{#1}{#2}}}
\newcommand{\dfloordiv}[2]{\floor{\dfrac{#1}{#2}}}
\newcommand{\isqrt}[1]{\floor{\sqrt{#1}}}
\newcommand{\softO}[0]{\widetilde{O}}
\newcommand{\softTheta}[0]{\widetilde{\Theta}}

\SetKwComment{Comment}{/* }{ */}
\IncMargin{2em}

\begin{document}
\maketitle %\thispagestyle{fancy}

\begin{abstract}
Let $\Phi(n) = \phi(1) + \cdots + \phi(n)$ be the totient summatory function.  We devise an algorithm for computing $\Phi(n)$ in time $\softO(n^{2/3})$ and space $\softO(n^{1/3})$.
\end{abstract}

\section{Notation}

Euler's totient function is denoted $\phi$.  Its summatory function is denoted $\Phi$.

The Dirichlet convolution of $f$ and $g$ is denoted by $f*g$.

The compositional identity function is denoted $I$.

The letter $\mu$ is used for both the M\"{o}bius function and an array such that $\mu_k = \mu(k)$.

The letter $M$ is used for both the Mertens function and an array such that $M_k = M(k)$.

We use $\delta(n) = \floor{1/n}$.  Note that this is the identity function for Dirichlet convolution.

\section{Existing algorithms}

The sieve of Eratosthenes can be modified to compute $\phi(n)$ for all $1 \leq n \leq n$, and therefore $\Phi(n)$, in time $\softO(n)$ and space $\softO(n^{1/2})$.\footnote{See file \texttt{totientsumA.py} for an implementation.}  Helfgott's sieve \cite{Helfgott2020} can be used to reduce the memory usage to $\softO(n^{1/3})$ in exchange for a logarithmic time penalty.  (\todo implement that)

Hirsch, Kessler, and Mendlovic outline \cite[\S5.6]{HKM2024} a method to compute $\Phi(n)$ in $\softO(n^{1/2})$ time and $\softO(n^{1/2})$ space.  However, this has never been implemented, and the hidden constants are expected to make the algorithm non-competitive for practical values of $n$.  \todo the HKM prime-counting algorithm has space-time tradeoffs.  What tradeoffs are available for $\Phi$?

By applying the Dirichlet hyperbola method to the convolution $\phi = \mu * I$, and letting $ab=n$, we obtain the formula
\eqn{\Phi(n) = \sum_{x=1}^{a}\sum_{y=1}^{n/x} \mu(x) \, I(y) + \sum_{y=1}^{b}\sum_{x=1}^{n/y} \mu(x) \, I(y) - \sum_{x=1}^{a}\sum_{y=1}^{b} \mu(x) \, I(y)}
\eqn{ = \sum_{x=1}^{a}\sum_{y=1}^{n/x} y \cdot \mu(x) + \sum_{y=1}^{b}\sum_{x=1}^{n/y} y \cdot \mu(x) - \sum_{x=1}^{a}\sum_{y=1}^{b} y \cdot \mu(x)}
\neqn{\Phi(n) = \underbrace{\sum_{x=1}^{a} \mu(x) \cdot \frac{\floordiv{n}{x} \cdot \left(\floordiv{n}{x} + 1\right)}{2}}_{X} + \underbrace{\sum_{y=1}^{b} y \cdot M(n/y)}_{Y} - \underbrace{\frac{b \cdot (b+1)}{2} \cdot M(a)}_{Z} \label{PhiFormula}}
The labels $X$, $Y$, and $Z$ will be used later.

Suppose that we have an algorithm that can compute $M(x)$ in time $\softO(x^c)$, and observe that sieving tells us that $c\leq1$ is available.  Using a sieve to compute the necessary M\"obius values, but otherwise evaluating this formula na\"{i}vely, takes time
\eqn{\softO\left( a + \sum_{x=1}^b \left(\frac{n}{x}\right)^c + a^c \right)}
\eqn{=\softO\left( a + n^c \integral{x^{-c}}{x}{1}{b} + a^c \right)}
\eqn{=\softO\left( a + n^c\frac{b^{1-c}}{1-c} - n^c\frac{1^{1-c}}{1-c} + a^c \right)}
\eqn{=\softO\left( a + n^c b^{1-c} - n^c + a^c \right)}
\eqn{=\softO\left( a + n^c n^{1-c} a^{c-1} - n^c + a^c \right)}
\eqn{=\softO\left( a + n a^{c-1} - n^c + a^c \right)}
The third term is always dominated by the second, and the fourth is always dominated by the first.
\eqn{=\softO\left( a + n a^{c-1} \right)}
To balance the contributions of the two terms, we take $a = \softO(n^{1/(2-c)})$.

The Del\'{e}glise-Rivat algorithm \cite{DR1996} allows $c=2/3$, and so using it in this algorithm sets $a=3/4$.  The time complexity is then $\softO(n^{3/4})$. 
 The Del\'{e}glise-Rivat algorithm is invoked for arguments up to $n$, so its contribution to the memory usage is $\softO(n^{1/3})$.  If the M\"{o}bius sieving is done with Helfgott's algorithm \cite{Helfgott2020}, then the sieving consumes $\softO(n^{1/4})$ space; if the traditional square-root segmentation is used then the sieving consumes $\softO(n^{3/8})$ space.\footnote{See file \texttt{totientsumB.py} for an implementation.}

The Mertens function can also be computed with the Helfgott-Thompson algorithm, which takes $\softO(n^{3/5})$ time and $\softO(n^{3/10})$ space.  Evaluating (\ref{PhiFormula}) as described then takes $\softO(n^{5/7})$ time, and we have $a = \softO(n^{5/7})$.  The space usage is then $\softO(n^{3/10})$ inside the Helfgott-Thompson algorithm and either $\softO(n^{5/14})$ or $\softO(n^{5/21})$, depending on which sieving method is used.

This algorithm suffers from the fact that all those $M(n/y)$-values are computed one at a time and are not given a chance to contribute to each other.  This can be ameliorated by another application of the Dirichlet hyperbola method.  This time, we use $\delta = \mu * 1$ and set $\alpha\beta=n$ to obtain
\eqn{\sum_{k=1}^n \delta(k) = \sum_{x=1}^{\alpha}\sum_{y=1}^{n/x} \mu(x) \cdot 1 + \sum_{y=1}^{\beta}\sum_{x=1}^{n/y} \mu(x) \cdot 1 - \sum_{x=1}^{\alpha}\sum_{y=1}^{\beta} \mu(x) \cdot 1}
\eqn{1 = \sum_{x=1}^{\alpha} \mu(x) \floordiv{n}{x} + \sum_{y=1}^{\beta} M(n/y) - M(\alpha) \floor{\beta}}
\neqn{M(n) = 1 + \floor{\beta} M(\alpha) - \sum_{x=1}^{\alpha} \mu(x) \floordiv{n}{x} - \sum_{y=2}^{\beta} M(n/y) \label{MertensRecursion}}
When evaluating (\ref{PhiFormula}), we need to find $\mu(k)$ for $1 \leq k \leq a$, $M(a)$, and $M(n/k)$ for $1 \leq k \leq b$.

When evaluating (\ref{MertensRecursion}), we need to find $\mu(k)$ for $1 \leq k \leq \alpha$, $M(\alpha)$, and $M(n/k)$ for $2 \leq k \leq \beta$.

Clearly, these work well together: we can take $\alpha=a$ (and therefore $\beta=b$), sieve $\mu$ up to $a$, accumulate the values along the way to compute $M$ up to $a$, use (\ref{MertensRecursion}) to compute the remaining Mertens values, and then feed all that data into (\ref{PhiFormula}) to compute $\Phi(n)$.  This results in Algorithm \ref{Algo1}.

\begin{algorithm}[H] \label{Algo1}
\DontPrintSemicolon
\caption{Compute $\Phi(n)$ in $\softTheta(n^{2/3})$ time and $\softTheta(n^{1/2})$ space \cite{griff2023}.  See file \texttt{totientsumC.py} for an implementation.}
\KwData{$n \geq 1$}
\KwResult{$\Phi(n)$}
\Begin{
    $a \gets \softTheta(n^{2/3})$; $b \gets \floor{n/a}$; $X \gets 0$; $Y \gets 0$; $Z \gets 0$; $m \gets 0$; $s \gets \isqrt{n}$ \label{1-p1start}
    
    \If{$\isqrt{n} = \floor{n/\isqrt{n}}$}{
        $s \gets s-1$
    }
    
    $\chi \gets \floor{n/s}$
    
    Prepare a segmented Sieve of Eratosthenes to compute $\mu(k)$ for $1 \leq k \leq a$.
    
    Let $\mu$ and $M$ be arrays indexed from $1$ through $\isqrt{n}$, inclusive.
    
    Let $M^\prime$ be an array indexed from $1$ through $\floor{n/\isqrt{n}}$, inclusive, initialized to all zeros. \label{1-endinit}
    \begin{multicols}{2}
    \For{$x=1$ \KwTo $a$}{ \label{1-p12loopstart}
        $v \gets \floor{n/x}$
        
        $m \gets m + \mu(x)$
        
        $X \gets X + \mu(x) \cdot \dfrac{v \cdot (v+1)}{2}$ \label{1-14}
        
        \uIf{$x \leq \isqrt{n}$}{ \label{1-p1a}
            $M_x \gets m$
            
            $\mu_x \gets \mu(x)$ \label{1-p1b}
        }
        \ElseIf{$x = \chi$}{ \label{1-p2a}
        
            \If{$v \neq b$}{ \label{1-17}
                $M^\prime_{v} \gets m$ \label{1-18}
            }
            
            $s \gets s-1$
            
            $\chi \gets \floor{n/s}$
        }
        \If{$x = a$}{
            $Z \gets m \cdot \dfrac{b \cdot (b+1)}{2}$ \label{1-p2b}
        }
    }
    
    \label{1-p1end}
    
    \For{$y=b$ \KwTo $1$}{ \label{1-p3start}
        $v \gets \floor{n/y}$
        
        $m \gets 1 - v + \isqrt{v} \cdot M_{\isqrt{v}}$
        
        \For{$x=2$ \KwTo $\isqrt{v}$}{
            $m \gets m - \mu_x \cdot \floor{v/x}$ \label{1-p3mobius}
            
            \uIf{$\floor{v/x} \leq \isqrt{n}$}{
                $m \gets m - M_{\floor{v/x}}$
            }
            \Else{
                $m \gets m - M^\prime_{\floor{n/\floor{v/x}}}$
            }
        }
        $M^\prime_y \gets M^\prime_y + m$
        
        $Y \gets Y + y \cdot M^\prime_y$ \label{1-p3end}
    }
    \end{multicols}
    
    \vspace{1em}
    
    \KwRet $X + Y - Z$
}
\end{algorithm}

Algorithm \ref{Algo1} has four phases:
\begin{enumerate} \addtocounter{enumi}{-1}
\item In the zeroth phase, lines \ref{1-p1start}--\ref{1-endinit} initialize the computation.
\item In the first phase, we sieving up to $\isqrt{n}$.  This is covered in lines \ref{1-p12loopstart}--\ref{1-p1b}.  In this phase, we sieve the M\"{o}bius function up to $\isqrt{n}$, accumulate its values to compute the Mertens function, save both $\mu$ and $M$, and accumulate terms from part $X$ of (\ref{PhiFormula}).
\item In the second phase, we continue the sieve up to $a$.  This is covered in lines \ref{1-p12loopstart}--\ref{1-p2b}, skipping lines \ref{1-14}--\ref{1-p1b}.  In this phase, we continue to accumulate M\"{o}bius values to compute Mertens values, and we continue to accumulate terms from part $X$ of (\ref{PhiFormula}), but we do not save any $\mu$, and only some Mertens values are saved.  As the final act of phase 2, we compute part $Z$ of (\ref{PhiFormula}).  At this point, $X$ and $Z$ are fully evaluated, and nothing has been done about $Y$.
\item In the third phase, lines \ref{1-p3start} through \ref{1-p3end} feed the stored M\"{o}bius and Mertens values into (\ref{MertensRecursion}) to compute the remaining Mertens values in order of increasing argument---that is, we first compute $M(n/b)$, then $M(n/(b-1))$, then ..., and finally $M(n)$.  As each Mertens value is computed, a term from part $Y$ of (\ref{PhiFormula}) becomes available, and we evaluate it accordingly.
\end{enumerate}
Once the third phase is done, $\Phi(n)$ is computed as $X+Y-Z$.

Line \ref{1-18} is gatekept by line \ref{1-17}.  This is needed to mitigate an overlap in the phases that occurs for some $(a,n)$ pairs.  In such cases, without the gatekeeping, line \ref{1-18} would set $M^\prime_b$ to $M(a)$, which should be its final value, but it then gets modifed in the first iteration through phase 3, which throws things off.  With line \ref{1-17} in place, $M^\prime_b$ is not touched until phase 3.

Algorithm \ref{Algo1} takes $\softTheta(n^{2/3})$ time: phases 0--2 combined clearly take $\softTheta(a)$ time, and phase 3 takes time
\eqn{\softTheta \left( \sum_{y=1}^b \left( \isqrt{\frac{n}{y}} - 1 \right) \right)}
\eqn{= \softTheta \left( \sum_{y=1}^b \left( \isqrt{\frac{n}{y}} \right) - b \right)}
\eqn{= \softTheta \left( \integral{ \sqrt{\frac{n}{y}} }{y}{1}{b} - b \right)}
\eqn{= \softTheta \left( \sqrt{n} 2 \eval{\sqrt{y}}{y=1}{b} - b \right)}
\eqn{= \softTheta \left( 2 \sqrt{n} \eval{\sqrt{y}}{y=1}{b} - b \right)}
\eqn{= \softTheta \left( 2 \sqrt{n} \left( \sqrt{b} - 1 \right) - b \right)}
\eqn{= \softTheta \left( \frac{n}{\sqrt{a}} \right).}

Algorithm 1 takes $\softTheta(\sqrt{n})$ space: we use three arrays of $\Theta(\sqrt{n})$ elements each to store the M\"{o}bius and Mertens values, the M\"{o}bius sieving consumes $\softO(\sqrt{a})$ space, and everything else fits in $O(1)$ space.

\section{A new algorithm}

We now reduce Algorithm \ref{Algo1}'s memory usage from $\softTheta(\sqrt{n})$ to $\softTheta(\sqrt[3]{n})$.  The first step is to observe that we can move line \ref{1-p3mobius} into phase 1.  The work done in that line is essentially as follows:

\begin{algorithm}[H] \label{Algo1mu}
\DontPrintSemicolon
\caption{An extract from Algorithm \ref{Algo1}}
\Begin{
    \For{$y=b$ \KwTo $1$}{
        \For{$x=2$ \KwTo $\isqrt{n/y}$}{
            $M^\prime_y \gets M^\prime_y - \mu_x \cdot \dfloordiv{n}{yx}$
        }
    }
}
\end{algorithm}

If we can swap the order of the loops, then we will be able to integrate this line into phase 1 and not have to store the M\"{o}bius array.

This extract iterates over all pairs $(y,x)$ such that $1 \leq y \leq b$ and $2 \leq x \leq \sqrt{n/y}$.  The range accessed by $x$ is therefore $2 \leq x \leq \sqrt{n}$, and for each $x$, $y$ ranges over $1 \leq y \leq \min(b, n/x^2)$.  This extract is therefore equivalent to

\begin{algorithm}[H] \label{Algo1mu_redone}
\DontPrintSemicolon
\caption{Algorithm \ref{Algo1mu}, reordered}
\Begin{
    \For{$x=2$ \KwTo $\isqrt{n}$}{
        \For{$y=1$ \KwTo $\min(b,\floor{n/x^2})$}{
            $M^\prime_y \gets M^\prime_y - \mu(x) \cdot \dfloordiv{n}{yx}$
        }
    }
}
\end{algorithm}

Applying this edit to Algorithm \ref{Algo1} replaces line \ref{1-p1b} with lines \ref{4-15}--\ref{4-17}, and removes line \ref{1-p3mobius} entirely.  The result is Algorithm \ref{Algo4}.

\begin{algorithm}[H] \label{Algo4}
\DontPrintSemicolon
\caption{Compute $\Phi(n)$ in $\softTheta(n^{2/3})$ time and $\softTheta(n^{1/2})$ space.  See file \texttt{totientsumD.py} for an implementation.}
\KwData{$n \geq 1$}
\KwResult{$\Phi(n)$}
\Begin{
    $a \gets \softTheta(n^{2/3})$; $b \gets \floor{n/a}$; $X \gets 0$; $Y \gets 0$; $Z \gets 0$; $m \gets 0$; $s \gets \isqrt{n}$ \label{4-2}
    
    \If{$\isqrt{n} = \floor{n/\isqrt{n}}$}{
        $s \gets s-1$
    }
    
    $\chi \gets \floor{n/s}$ \label{4-5}
    
    Prepare a segmented Sieve of Eratosthenes to compute $\mu(x)$ for $1 \leq x \leq a$.
    
    Let $M$ be an array indexed from $1$ through $\isqrt{n}$, inclusive.
    
    Let $M^\prime$ be an array indexed from $1$ through $\floor{n/\isqrt{n}}$, inclusive, initialized to all zeros.
    \begin{multicols}{2}
    \For{$x=1$ \KwTo $a$}{
        $v \gets \floor{n/x}$
        
        $m \gets m + \mu(x)$
        
        $X \gets X + \mu(x) \cdot \dfrac{v \cdot (v+1)}{2}$
        
        \uIf{$x \leq \isqrt{n}$}{
            $M_x \gets m$
            
            \If{$x > 1$}{ \label{4-15}
                \For{$y=1$ \KwTo $\min(b,\floor{n/x^2})$}{
                    $M^\prime_y \gets M^\prime_y - \mu(x) \cdot \dfloordiv{n}{yx}$ \label{4-17}
                }
            }
        }
        \ElseIf{$x = \chi$}{
        
            \If{$v \neq b$}{
                $M^\prime_{v} \gets m$
            }
            
            $s \gets s-1$
            
            $\chi \gets \floor{n/s}$
        }
        \If{$x = a$}{
            $Z \gets m \cdot \dfrac{b \cdot (b+1)}{2}$
        }
    }
    
    \For{$y=b$ \KwTo $1$}{
        $v \gets \floor{n/y}$
        
        $m \gets 1 - v + \isqrt{v} \cdot M_{\isqrt{v}}$ \label{4-27}
        
        \For{$x=2$ \KwTo $\isqrt{v}$}{
            \uIf{$\floor{v/x} \leq \isqrt{n}$}{
                $m \gets m - M_{\floor{v/x}}$
            }
            \Else{
                $m \gets m - M^\prime_{\floor{n/\floor{v/x}}}$
            }
        }
        $M^\prime_y \gets M^\prime_y + m$
        
        $Y \gets Y + y \cdot M^\prime_y$
    }
    \end{multicols}
    
    \vspace{1em}
    
    \KwRet $X + Y - Z$
}
\end{algorithm}

The next step is to move line \ref{4-27} into phase 1.  The work this line does is essentially

\begin{algorithm}[H] \label{Algo4extract}
\DontPrintSemicolon
\caption{An extract from Algorithm \ref{Algo4}}
\Begin{
    \For{$y=b$ \KwTo $1$}{
        $M^\prime_y \gets M^\prime_y + 1 - \floor{n/y} + \isqrt{n/y} \cdot M_{\isqrt{n/y}}$
    }
}
\end{algorithm}

This is equivalent to

\begin{algorithm}[H] \label{Algo4extract_redone}
\DontPrintSemicolon
\caption{Algorithm \ref{Algo4extract}, redone}
\Begin{
    \For{$x=1$ \KwTo $a$}{
        \If{$\exists y \;\ni\; 1 \leq y \leq b \;\;\&\;\; x=\isqrt{n/y}$}{
            \For{all such $y$}{
                $M^\prime_y \gets M^\prime_y + 1 - \floor{n/y} + x \cdot M_x$
            }
        }
    }
}
\end{algorithm}

\begin{algorithm}[H] \label{Algo4extract_redone_again}
\DontPrintSemicolon
\caption{Algorithm \ref{Algo4extract}, redone again}
\Begin{
    
    $d \gets b$
    
    $\gamma \gets \isqrt{n/d}$
    
    \For{$x=1$ \KwTo $a$}{
        
        \While{$x = \gamma$}{
            $M^\prime_d \gets M^\prime_d + 1 - \floor{n/d} + x \cdot M_x$
            
            $d \gets d - 1$
            
            $\gamma \gets \isqrt{n/d}$
        }
    }
}
\end{algorithm}

Applying this edit to Algorithm \ref{Algo4} yields Algorithm \ref{Algo8}.  Lines \ref{4-2} and \ref{4-5} have had actions added to them, lines \ref{8-18}--\ref{8-21} have been inserted, and line \ref{4-27} has been replaced with line \ref{8-31}.

\begin{algorithm}[H] \label{Algo8}
\DontPrintSemicolon
\caption{Compute $\Phi(n)$ in $\softTheta(n^{2/3})$ time and $\softTheta(n^{1/2})$ space.  See file \texttt{totientsumE.py} for an implementation.}
\KwData{$n \geq 1$}
\KwResult{$\Phi(n)$}
\Begin{
    $a \gets \softTheta(n^{2/3})$; $b \gets \floor{n/a}$; $X \gets 0$; $Y \gets 0$; $Z \gets 0$; $m \gets 0$; $s \gets \isqrt{n}$; $d \gets b$
    
    \If{$\isqrt{n} = \floor{n/\isqrt{n}}$}{
        $s \gets s-1$
    }
    
    $\chi \gets \floor{n/s}$; $\gamma \gets \isqrt{n/d}$
    
    Prepare a segmented Sieve of Eratosthenes to compute $\mu(x)$ for $1 \leq x \leq a$.
    
    Let $M$ be an array indexed from $1$ through $\isqrt{n}$, inclusive. \label{8-7}
    
    Let $M^\prime$ be an array indexed from $1$ through $\floor{n/\isqrt{n}}$, inclusive, initialized to all zeros.
    \begin{multicols}{2}
    \For{$x=1$ \KwTo $a$}{
        $v \gets \floor{n/x}$
        
        $m \gets m + \mu(x)$
        
        $X \gets X + \mu(x) \cdot \dfrac{v \cdot (v+1)}{2}$
        
        \uIf{$x \leq \isqrt{n}$}{
            $M_x \gets m$ \label{8-14}
            
            \If{$x > 1$}{
                \For{$y=1$ \KwTo $\min(b,\floor{n/x^2})$}{
                    $M^\prime_y \gets M^\prime_y - \mu(x) \cdot \dfloordiv{n}{yx}$
                }
                \While{$x = \gamma$}{ \label{8-18}
                    $M^\prime_d \gets M^\prime_d + 1 - \floor{n/d} + x \cdot M_x$
                    
                    $d \gets d - 1$
                    
                    $\gamma \gets \isqrt{n/d}$ \label{8-21}
                }
            }
        }
        \ElseIf{$x = \chi$}{
        
            \If{$v \neq b$}{
                $M^\prime_{v} \gets m$
            }
            
            $s \gets s-1$
            
            $\chi \gets \floor{n/s}$
        }
        \If{$x = a$}{
            $Z \gets m \cdot \dfrac{b \cdot (b+1)}{2}$
        }
    }
    
    \For{$y=b$ \KwTo $1$}{
        $v \gets \floor{n/y}$
        
        $m \gets 0$ \label{8-31}
        
        \For{$x=2$ \KwTo $\isqrt{v}$}{
            \uIf{$\floor{v/x} \leq \isqrt{n}$}{ \label{8-33}
                $m \gets m - M_{\floor{v/x}}$ \label{8-34}
            }
            \Else{ \label{8-35}
                $m \gets m - M^\prime_{\floor{n/\floor{v/x}}}$
            }
        }
        $M^\prime_y \gets M^\prime_y + m$
        
        $Y \gets Y + y \cdot M^\prime_y$
    }
    
    \end{multicols}
    
    \vspace{1em}
    
    \KwRet $X + Y - Z$
}
\end{algorithm}

The final obstacle to removing array $M$ is line \ref{8-34}.  The work this line does is essentially

\begin{algorithm}[H] \label{Algo8_extract}
\DontPrintSemicolon
\caption{An extract from Algorithm \ref{Algo8}}
\Begin{
    \For{$y=b$ \KwTo $1$}{
        $v \gets \floor{n/y}$
        
        $m \gets 0$
        
        \For{$x=2$ \KwTo $\isqrt{v}$}{
            \If{$\floor{v/x} \leq \isqrt{n}$}{
                $m \gets m - M_{\floor{v/x}}$
            }
        }
        $M^\prime_y \gets M^\prime_y + m$
    }
}
\end{algorithm}

This extract iterates over all pairs $(x,y)$ with
\neqn{1 \leq y \leq b \qquadtext{and} 2 \leq x \leq \isqrt{n/y} \qquadtext{and} \floor{n/(xy)} \leq \isqrt{n} \label{bafnehkj}}
and, for each such pair, subtracts $M_{\floor{n/(xy)}}$ from $M^\prime_y$.  Note that the third inequality is equivalent to this action all happening during phase 1.  Let $k = \floor{n/(xy)}$.  Then for each Mertens value $M(k)$ that we compute, we must find all pairs of integers $(x,y)$ subject to the above bounds and
\eqn{k \leq \frac{n}{xy} < k+1}
\eqn{\frac{1}{k+1} < \frac{xy}{n} \leq \frac{1}{k}}
\eqn{\frac{n}{k+1} < xy \leq \frac{n}{k}.}
Addressing a single $k$ at a time is awfully close to factoring $n/k$.  To avoid breaking the clock, we will instead gather a block of consecutive Mertens values and address them all at once.  When this algorithm is fully developed, the memory usage will be $\softO(\sqrt[3]{n})$ due to the array $M^\prime$ and storage inside the M\"{o}bius siever; we will therefore gather Mertens batches of size $b$.  The high index of each batch will be $x$, and the low index will be $A \defeq 1 + b \cdot \floor{x/b}$.  The result is that, when processing each batch, we will be looking for all pairs $(t, \ell)$ such that
\eqn{1 \leq t \leq b \qquadtext{and} 2 \leq \ell \leq \sqrt{n/t} \qquadtext{and} A = b \cdot \floordiv{x}{b} + 1 \qquadtext{and} A \leq \floordiv{n}{\ell t} \leq x.}
Since $A$ and $x$ are integers, the rightmost condition is equivalent to
\eqn{A \leq \frac{n}{\ell t} < x + 1}
\eqn{\frac{1}{x+1} < \frac{\ell t}{n} \leq \frac{1}{A}}
\eqn{\frac{n}{t \cdot (x+1)} < \ell \leq \frac{n}{At}.}
Algorithm \ref{Algo8_extract} is therefore equivalent to

\begin{algorithm}[H] \label{Algo8_extract_redone}
\DontPrintSemicolon
\caption{Algorithm \ref{Algo8_extract}, redone}
\Begin{
    \For{$x=1$ \KwTo $a$}{
        \If{$x \leq \sqrt{n}$}{
            $\mathcal{M}_x \gets m$
        }
        
        \If{$b \mid x$, or $x = \isqrt{n}$,}{
            Let $A$ be the least index in $\mathcal{M}$.
            
            \For{$t=1$ \KwTo $b$}{
                $\ell_{min} \gets \max\left( 2 , 1 + \dfloordiv{n}{t \cdot (x+1)} \right)$
                
                $\ell_{max} \gets \min\left( \isqrt{n/t} , \dfloordiv{n}{t \cdot A} \right)$
                
                \For{$\ell=\ell_{min}$ \KwTo $\ell_{max}$}{
                    $M^\prime_t \gets M^\prime_t - \mathcal{M}_{\floor{n/(\ell t)}}$
                }
            }
            
            Forget the contents of $\mathcal{M}$.
        }
    }
}
\end{algorithm}

Applying this edit to Algorithm \ref{Algo8} yields Algorithm \ref{Algo11}.  Lines \ref{8-7} and \ref{8-14} have been deleted, lines \ref{8-33}--\ref{8-35} have been replaced with \ref{11-41}, and lines \ref{11-8}, \ref{11-14}, and \ref{11-22}--\ref{11-29} have been inserted.

\begin{algorithm}[H] \label{Algo11}
\DontPrintSemicolon \footnotesize
\caption{Compute $\Phi(n)$ in $\softTheta(n^{2/3})$ time and $\softTheta(n^{1/2})$ space.  See file \texttt{totientsumG.py} for an implementation.}
\KwData{$n \geq 1$}
\KwResult{$\Phi(n)$}
\Begin{
    $a \gets \softTheta(n^{2/3})$; $b \gets \floor{n/a}$; $X \gets 0$; $Y \gets 0$; $Z \gets 0$; $m \gets 0$; $s \gets \isqrt{n}$; $d \gets b$
    
    \If{$\isqrt{n} = \floor{n/\isqrt{n}}$}{
        $s \gets s-1$
    }
    
    $\chi \gets \floor{n/s}$; $\gamma \gets \isqrt{n/d}$
    
    Prepare a segmented Sieve of Eratosthenes to compute $\mu(x)$ for $1 \leq x \leq a$.
    
    Let $M^\prime$ be an array indexed from $1$ through $\floor{n/\isqrt{n}}$, inclusive, initialized to all zeros.
    
    Let $\mathcal{M}$ be an array of size $b$.  Its indexing will vary as the algorithm executes. \label{11-8}
    
    \vspace{1em}
    
    \begin{multicols}{2}
    \For{$x=1$ \KwTo $a$}{
        $v \gets \floor{n/x}$
        
        $m \gets m + \mu(x)$
        
        $X \gets X + \mu(x) \cdot \dfrac{v \cdot (v+1)}{2}$
        
        \uIf{$x \leq \isqrt{n}$}{
            $\mathcal{M}_x \gets m$ \label{11-14}
            
            \If{$x > 1$}{
                \For{$y=1$ \KwTo $\min(b,\floor{n/x^2})$}{
                    $M^\prime_y \gets M^\prime_y - \mu(x) \cdot \dfloordiv{n}{yx}$
                }
                \While{$x = \gamma$}{
                    $M^\prime_d \gets M^\prime_d + 1 - \floor{n/d} + x \cdot M_x$
                    
                    $d \gets d - 1$
                    
                    $\gamma \gets \isqrt{n/d}$
                }
                \If{$b \mid x$, or $x = \isqrt{n}$,}{ \label{11-22}
                    Let $A$ be the least index in $\mathcal{M}$.
                    
                    \For{$t=1$ \KwTo $b$}{
                        $\ell_{min} \gets \max\left( 2 , 1 + \dfloordiv{n}{t \cdot (x+1)} \right)$
                        
                        $\ell_{max} \gets \min\left( \isqrt{n/t} , \dfloordiv{n}{t \cdot A} \right)$
                        
                        \For{$\ell=\ell_{min}$ \KwTo $\ell_{max}$}{
                            $M^\prime_t \gets M^\prime_t - \mathcal{M}_{\floor{n/(\ell t)}}$
                        }
                    }
                    
                    Forget the contents of $\mathcal{M}$. \label{11-29}
                }
            }
        }
        \ElseIf{$x = \chi$}{
        
            \If{$v \neq b$}{
                $M^\prime_{v} \gets m$
            }
            
            $s \gets s-1$
            
            $\chi \gets \floor{n/s}$
        }
        \If{$x = a$}{
            $Z \gets m \cdot \dfrac{b \cdot (b+1)}{2}$
        }
    }
    
    \For{$y=b$ \KwTo $1$}{
        $v \gets \floor{n/y}$
        
        $m \gets 0$
        
        \For{$x=2$ \KwTo $\isqrt{v}$}{
            \If{$\floor{v/x} > \isqrt{n}$}{ \label{11-41}
                $m \gets m - M^\prime_{\floor{n/\floor{v/x}}}$
            }
        }
        $M^\prime_y \gets M^\prime_y + m$
        
        $Y \gets Y + y \cdot M^\prime_y$
    }
    
    \end{multicols}
    
    \vspace{1em}
    
    \KwRet $X + Y - Z$
}
\end{algorithm}







\section{Python code}

%\showcode{totientsumA}

Filename: \texttt{utils.py}
%\lstinputlisting[language=Python, caption={Utiliity functions---a prime-number generator, a $\floor{\isqrt[n]{x}}$-computer, a M\"{o}bius siever, and the Mertens function using the Del\'{e}glise--Rivat algorithm.}]{code/utils.py}

Filename: \texttt{totientsumA.py}
%\lstinputlisting[language=Python, caption={Computation of $\Phi(N)$ by sieving $\phi$ from 1 to $N$.}]{code/totientsumA.py}

Filename: \texttt{totientsumB.py}
%\lstinputlisting[language=Python, caption={Computation of $\Phi(N)$ by na\"{i}vely evaluating (\ref{PhiFormula}).}]{code/totientsumB.py}

Filename: \texttt{totientsumC.py}
%\lstinputlisting[language=Python, caption={Computation of $\Phi(N)$ by Algorithm \ref{Algo1}.}]{code/totientsumC.py}

Filename: \texttt{totientsumD.py}
%\lstinputlisting[language=Python, caption={Computation of $\Phi(N)$ by Algorithm \ref{Algo4}.}]{code/totientsumD.py}

Filename: \texttt{totientsumE.py}
%\lstinputlisting[language=Python, caption={Computation of $\Phi(N)$ by Algorithm \ref{Algo8}.}]{code/totientsumE.py}

Filename: \texttt{totientsumF.py}
%\lstinputlisting[language=Python, caption={Computation of $\Phi(N)$ by an unbatched version of Algorithm \ref{Algo11}.}]{code/totientsumF.py}

Filename: \texttt{totientsumG.py}
%\lstinputlisting[language=Python, caption={Computation of $\Phi(N)$ by Algorithm \ref{Algo11}.}]{code/totientsumG.py}



\nocite{*}

\oeisref{002088}

\setlength{\bibitemsep}{\parskip}
\printbibliography[heading=bibnumbered]

\end{document}



\begin{algorithm}
\DontPrintSemicolon
\caption{Caption} \label{Algq35yt6q35y}
\KwData{$n \geq 0$}
\KwResult{$y = x^n$}
\Begin{
  $y \gets 1$\;
  $X \gets x$\;
  $N \gets n$\;
  \While{$N \neq 0$}{
    \eIf{$N$ is even}{
      $X \gets X \times X$\;
      $N \gets \frac{N}{2} $ \Comment*[r]{This is a comment}
    }{\If{$N$ is odd}{ \label{AlgorithmLineExample}
        $y \gets y \times X$\;
        $N \gets N - 1$\;
      }
    }
    \For{$j \leftarrow 2$ \KwTo $w$}{
      do stuff\;
      \uIf{Test}{
        do stuff
      }
      \uElseIf{test2}{
        do stuff
      }
      \Else{
        do stuff
      }
    }
  }
}
\end{algorithm}

A\ref{Algq35yt6q35y}.\ref{AlgorithmLineExample}

